<center><h1>Apple_RSL：<br>基于领域特定语言的客服机器人设计与实现<h1><center>


<center><h4>王冠达<br> 学号：2021211120<br> 班级：2021211306<h4><center>
# 1 引言

## 1.1 项目概述

本项目要求定义一个领域特定脚本语言，这个语言能够描述在线客服机器人（机器人客服是目前提升客服效率的重要技术，在银行、通信和商务等领域的复杂信息系统中有广泛的应用）的自动应答逻辑，并设计实现一个解释器解释执行这个脚本，可以根据用户的不同输入，根据脚本的逻辑设计给出相应的应答。

\- 脚本语言的语法可以自由定义，只要语义上满足描述客服机器人自动应答逻辑的要求。

\- 程序输入输出形式不限，可以简化为纯命令行界面。

\- 应该给出几种不同的脚本范例，对不同脚本范例解释器执行之后会有不同的行为表现。

## **1.2 定义**

### **领域特定语言（DSL）**

领域特定语言（Domain Specific Language，DSL）是用于特定领域的业务流程定制的，具有受限表达性的一种计算机程序设计语言。 常用于聚焦指定的领域或问题，这就要求 DSL 具备强大的表现力，同时提供一种相对简单的文法，使用起来简单。

- DSL，Domain Specific Language，领域特定语言
- GPL，General Purpose Language，通用编程语言

常见的DSL有：

- SQL（用于数据库查询的DSL）
- HTML（用于描述网页内容的DSL）
- CSS（用于描述网页样式的DSL）

![30a5b928-3889-4f32-9094-5c85e8025137](/Users/xiangri/Pictures/TyporaPics/30a5b928-3889-4f32-9094-5c85e8025137.png)

### 脚本（ Script )

为了特定目的，使用特定语法编写的一个文本文件，描述了一个流程，可以被一个解释器解释执行，以完成特定的的功能。

## 1.2 项目目标

我的DSL（领域特定语言）项目定义了一个在线客服机器人。这个DSL的命令被分为六个主要类别：产品信息、订单处理、退货和退款、技术支持、公司政策和促销活动。每一个类别下都有多个具体的命令。区别于其他实现，本项目的目标与特色为：

1. **高度定制的Apple_RSL实现：**
   - 根据真实需求对语法进行优化与适配。建立专为本项目开发的Apple_RSL脚本语言。
   - 语言逻辑力求简单直观，在用户发出涉及个人信息的请求时再进行身份验证而非必须登录前验证。
2. **现代化、简洁优雅的图形化界面：**
   - 设计界面时注重用户体验，确保操作直观，界面友好，以简洁美观的视觉元素减少用户的学习曲线。
   - 字号、标题、按钮大小与位置均为经过仔细考虑多次迭代后的设计。
   - 兼容深色、浅色两种模式。
   - 参考openAI、Anthropic等的实现，界面设计融入最新的UI设计趋势。
3. **全面模拟Apple支持的处理逻辑：**
   - 详尽模拟Apple客服在进入人工对话环节前可自动处理的逻辑，包括选购及了解、订单处理、账户管理、技术支持、公司政策和促销活动等6个方面。
   - 开发配套的测试套件，通过自动化测试确保模拟逻辑的准确性和可靠性。

## 1.3 开发环境

- macOS Sonoma 14.2.1
- PyCharm 2023.3.2
- OpenJDK 64-Bit Server VM by JetBrains s.r.o.



# 2 记法

## 2.1 记法定义

使用BNF（巴科斯范式）来定义DSL的语法。

```stylus
<Script> ::= <Step>+
<Step> ::= "Step" <Identifier> <NewLine> <Command>+
<Command> ::= <Say> | <Listen> | <Branch> | <Awake> | <Default> | <Exit>

<Say> ::= "SAY" <QuotedString> <NewLine>
<Listen> ::= "LISTEN" <Number> <Number> <NewLine>
<Branch> ::= "BRANCH" <QuotedString> <Identifier> <NewLine>
<Awake> ::= "AWAKE"  <Identifier> <NewLine>
<Default> ::= "DEFAULT" <Identifier> <NewLine>
<Exit> ::= "EXIT" <NewLine>

<Identifier> ::= <Letter> (<Letter> | <Digit> | "_")*
<Number> ::= <Digit>+
<QuotedString> ::= "\"" <AnyCharacterExceptQuote>* "\""
<Letter> ::= [A-Z a-z]
<Digit> ::= [0-9]
<AnyCharacterExceptQuote> ::= [^"]; Any character except for the quotation mark
<NewLine> ::= "\n" ; Represents a newline character
```

在这个DSL定义中：

- `<Script>`：是由一个或多个 `<Step>` 组成的序列。
- `<Step>`：每个步骤以关键字 "Step" 开始，后跟一个标识符 `<Identifier>` 和一个新行 `<NewLine>`。然后是一个或多个命令 `<Command>`。
- `<Command>`：命令可以是以下选项之一：`<Say>`、`<Listen>`、`<Branch>`、`<Awake>`、`<Default>` 或 `<Exit>`。
- `<Say>`：该命令输出一个被引号包围的字符串 `<QuotedString>`，模拟系统发出语音输出。
- `<Listen>`：该命令用于监听输入，后面跟有两个数字 `<Number>`，表示监听的最小持续时间和超时时间。
- `<Branch>`：该命令在脚本中创建一个决策点，基于用户输入决定下一步执行哪个步骤，根据给定的条件（一个引用字符串 `<QuotedString>`）转移到另一个标识符 `<Identifier>`。
- `<Awake>`：指示超时后的下一步动作，在此之后系统将进入保活状态，第二次超时后自动断开连接。
- `<Default>`：定义了超时或无法识别输入时跳转到的默认步骤，由 `<Identifier>` 标识。
- `<Exit>`：退出脚本或当前上下文。

其他如 `<Identifier>`、`<Number>`、`<QuotedString>`、`<Letter>`、`<Digit>` 和 `<AnyCharacterExceptQuote>` 等构件用于构建脚本中所需的字符串、数字和标识符。

### **巴科斯范式（BNF）**

上述定义使用的语法称为**巴科斯范式**（Backus-Naur Form，简称BNF），它是一种用于表示上下文无关文法的符号方式，通常用于计算机语言的语法规则描述。为避免歧义、便于理解，本部分说明定义中用到的符号及其含义：

- `::=`：定义操作符，表示定义的开始，左边是被定义的符号（非终结符），右边是定义的具体规则或者模式。
- `|`：选择操作符，表示在其左右两边的选项中选择一个，相当于逻辑中的“或”操作。
- `+`：表示一个或多个的前面的元素，例如 `<Step>+` 表示一个或多个`<Step>`。
- `*`：表示零个或多个的前面的元素，类似正则表达式中的用法。
- `< ... >`：尖括号内的文本表示非终结符，即需要进一步定义的符号。
- `" ... "`：双引号内的文本表示终结符，通常是具体的字符串或字符，如命令名或关键字。
- `( ... )`：圆括号用来分组，指定操作符的作用范围。
- `\n`：表示新行字符。

## 2.2 脚本设计

本Apple_RSL系统涵盖消费者业务的六大场景：选购及了解、订单处理、账户管理、技术支持、公司政策和促销活动。

1. **选购及了解**：了解官网在售产品。
2. **订单处理**：查询用户的订阅信息，订单状态，退货状态等。
3. **账户管理**：处理 AppleID 账户相关问题。
4. **技术支持**：解决用户在使用产品过程中遇到的技术问题。
5. **公司政策**：例如隐私政策，退货政策，商务信息等。
6. **促销活动**：提供最新的促销活动信息。

在实际应用场景中，可以将其全部整合进一个脚本，使得用户通过一个接口（不论是电话、微信公众号、官网等方式）可以直达所有服务类别，根据需求进行对应的处理。

也可以将6个功能划分为4个脚本，分别分别接入对应的渠道，模拟不同的真实使用场景。

- 售前服务`pre_sale_service`：选购及了解、促销活动、公司政策
- 售后服务`after_sale_service`：订单处理、技术支持、公司政策
- 客户支持`customer_support`：账户管理、订单处理
- 微信端口`wechat_api`：选购及了解、促销活动、订单处理

使用扩展巴科斯范式（EBNF）的一种形式，定义目前支持的**功能**：
每个构造块代表了DSL中的一个语法规则，定义了该板块的不同命令及其参数。

```stylus
command: 
  | 'shopping' '{' shopping_commands '}'
  | 'order' '{' validation_orders '}'
  | 'account' '{' validation_account '}'
  | 'support' '{' validation_support '}'
  | 'policy' '{' policy_commands '}'
  | 'promotion' '{' promotion_commands '}'
;

validation:
  | 'validation_orders' '{' order_commands '}'
  | 'validation_account' '{' account_commands '}'
  | 'validation_support' '{' support_commands '}'
;

shopping_commands: 
  | 'iphone_info' '(' STRING ')'
  | 'ipad_info' '(' STRING ')'
  | 'mac_info' '(' STRING ')'
  | 'airpods_info' '(' STRING ')'
;

order_commands:
  | 'subscription_info' '(' STRING ')'
  | 'order_status' '(' STRING ')'
  | 'return_status' '(' STRING ')'
;

account_commands:
  | 'icloud_account' '( STRING )'
  | 'apple_id' '(' STRING ')'
  | 'wallet' '(' STRING ')'
;

support_commands:
  | 'troubleshoot' '(' STRING ')'
  | 'how_to_fix' '(' STRING ')'
  | 'genius_bar' '(' STRING ')'
  | 'applecare_plus' '(' STRING ')'
;

policy_commands:
  | 'privacy_policy' '( STRING )'
  | 'return_policy' '( STRING )'
  | 'accessibility' '( STRING )'
;

promotion_commands:
  | 'current_event' '( STRING )'
  | 'edu_retail' '( STRING )'
  | 'business_retail' '(' STRING ')'
  | 'healthcare_retail' '( STRING )'
  | 'refurbished' '(' STRING ')'
;
```

- `command`：定义了一组高级命令，代表自动应答机器人的不同功能（如购物、订单、账户等）。
- `validation`：为不同的动作（账单、账户和支持）定义了一组验证。
- `shopping_commands`：指定了与购物相关的命令，例如查询iPhone、iPad、Mac和AirPods的信息。
- `order_commands`：指定了与订单相关的命令，例如获取订阅信息、订单状态和退货状态。
- `account_commands`：指定了与账户相关的信息，包括iCloud、Apple ID和钱包。
- `support_commands`：指定了与支持相关的查询和服务。
- `policy_commands`：指定了查询各种政策的命令，如隐私、退货和无障碍。
- `promotion_commands`：指定了促销活动和交易的命令。

每个命令后面跟着一系列用大括号 `{}` 括起来的动作，动作中的参数用括号 `()` 括起来，为字符串（`STRING`）。

最终生成4个脚本文件：

- `script_pre_sale.txt`
- `script_after_sale.txt`
- `script_support.txt`
- `script_wechat.txt`



# 3 系统架构

## 3.1 模块划分

代码整体架构划分为Parser、Interpreter和GUI三部分。每个部分均设计了对应的类进行封装。

### Parser：Script、Step 类

```
+---------------------------------+
|            Script               |
+---------------------------------+
| - steps: List[Step]             |
| - vars: Dictionary              |
| - actions: Dictionary           |
| - entry: Step                   |
+---------------------------------+
| + add_step(step: Step): void    |
+---------------------------------+

         |
         | contains
         V

+---------------------------------+
|             Step                |
+---------------------------------+
| - name: String                  |
| - expressions: List[String]     |
| - listen: List[int]             |
| - answers: Dictionary[String]   |
| - default: String               |
| - awake: String                 |
+---------------------------------+


+---------------------------------+
|     get_script_from_file()      |
+---------------------------------+
| + file_name: String             |
| + return: Script                |
+---------------------------------+
```

### Interpreter：Interpreter 类

```
+---------------------------------+
|          Interpreter            |
+---------------------------------+
| - current_step: Step            |
| - script: Script                |
| - loop: QEventLoop              |
| - timer: QTimer                 |
+---------------------------------+
| +__init__(script: Script)       |
| + run(): void                   |
| + execute_step(step: Step): void|
| + speak(expression: String): void|
| + listen(step: Step): String    |
| + on_submit(): void             |
| + on_timeout(): void            |
| +get_next_step_id(step: [StepType], intent: str) |
| +find_step_by_id(step_id: str)  |
| +check_user_exists(username: str) |
| +initial_message(): str         |
| +receive_user_input(user_input: str) |
| +closeApplication()             |
+---------------------------------+
| [signal] response_signal()      |
+---------------------------------+
```

### GUI ：ChatDialog类

```
+-----------------------------------+
|          ChatDialog               |
+-----------------------------------+
| -interpreter: Interpreter         |
| -textEdit: QTextEdit              |
| -inputLine: QLineEdit             |
| -sendButton: QPushButton          |
+-----------------------------------+
| +__init__(interpreter: Interpreter) |
| +initUI()                         |
| +append_text(text: str, speaker: str) |
| +send_message()                   |
+-----------------------------------+
```

## 3.2 技术选型

1. **编程语言：Python**
   - **理由**：Python是一种高级编程语言，以其简洁的语法和强大的标准库而闻名。它拥有丰富的第三方库支持，适合快速开发和原型制作。本项目需要的模块化、脚本设计、测试等需求均可以用Python很好地完成。
2. **图形用户界面框架：PyQt5**
   - **理由**：PyQt5是Qt库的Python接口，提供了丰富的GUI组件和工具，可以创建跨平台的桌面应用程序。它采用信号和槽机制来处理事件，这有助于分离用户界面逻辑和业务逻辑，使得代码更加模块化和易于维护。
4. **应用程序结构：事件驱动架构**
   - **理由**：事件驱动架构非常适合构建用户界面应用，能够响应用户的交互和程序的异步事件。PyQt5天然支持事件驱动模型，这使得开发具有响应性和交互性的应用程序更加直接。
5. **数据存储：JSON文件**
   - **理由**：JSON是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。考虑到脚本的结构可能简单且不需要复杂的查询，JSON文件提供了足够的灵活性和简单性，避免了数据库的过度设计。

## 3.3 功能模块

![IMG_5D16F4F2501A-1](/Users/xiangri/Pictures/TyporaPics/IMG_5D16F4F2501A-1.jpeg)

### Parser

- **主模块**：
  - 定义了`Step`和`Script`类。
  - 定义了文件解析函数`parse_file`、`parse_line`、`process_tokens`等。
  - 包含了主程序入口，它检查命令行参数，调用`get_script_from_file`来解析脚本文件。

- **Step 类**：
  - 存储步骤名称、表达式列表、监听时长、答案字典、默认和保活后继状态。
- **Script 类**：
  - 存储步骤列表、变量、动作字典、入口步骤。
  - 提供`add_step`方法来添加新的步骤。
- **解析函数**：
  - `parse_file`：读取脚本文件并逐行解析。
  - `parse_line`：处理文件中的每一行，跳过注释并分解为标记。
  - `process_tokens`：根据标记的类型执行相应的处理。
  - `process_step`、`process_say`、`process_listen`、`process_branch`：分别处理脚本文件中的步骤、说、听和分支逻辑。

### Interpreter_GUI

- **主模块**：
  - 导入必要的PyQt5模块和其他模块。
  - 定义了全局变量`svg_data`，包含SVG图标数据。
  - 创建并运行`QApplication`，初始化聊天对话窗口。

- **ChatDialog 类（QWidget）**：
  - `__init__`：构造函数，初始化聊天对话框，并调用`initUI`。
  - `initUI`：设置聊天对话框界面，包括窗口标题、大小、布局、输入框和按钮。
  - `append_text`：在文本区域添加新文本。
  - `send_message`：处理发送消息的逻辑。

- **Interpreter 类（QObject）**：
  - `__init__`：构造函数，初始化解释器，设置计时器。
  - `run`：启动解释器的执行。
  - 其他方法：包括处理当前步骤、发言、监听、提交和超时等。



# 4 程序设计

## 4.1 数据结构

### Parser

- **Step**：
  - 表示脚本中的单个步骤，包含步骤相关的属性。
  - `name`：字符串类型，存储步骤的名称。
  - `expressions`：列表类型，存储要输出的句子，列表的大小取决于脚本中 SAY 命令的数量。
  - `listen`：列表类型，存储监听的时长范围，有两个整数元素，表示最小和最大时长。
  - `answers`：字典类型，键是字符串，值也是字符串，表示可能的用户回答和对应的后继状态。
  - `default` 和 `awake`：字符串类型，存储默认和无响应时的后继状态名称。

- **Script**：
  - 表示整个脚本，包含所有步骤和脚本执行所需的其他元素。
  - `steps`：列表类型，存储脚本中所有`Step`对象的实例。
  - `vars`：字典类型，用于存储运行时的变量及其值，具体数据类型取决于变量的使用方式和内容。
  - `actions`：字典类型，存储可能的动作和对应的结果。
  - `entry`：`Step`类型，指向脚本的入口步骤。

### Interpreter_GUI

- **ChatDialog**：
  - 包含界面组件如`textEdit`（QTextEdit），`inputLine`（QLineEdit），`sendButton`（QPushButton）。
  - `QTextEdit`：一个富文本编辑器，用于显示聊天历史。此组件在内存中维护文本的结构，其大小取决于存储的文本量。
  - `QLineEdit`：一个单行文本输入框，用于用户输入消息。
  - `QPushButton`：一个按钮，用户可以点击它来发送消息。主要用于存储按钮的状态和样式。
  - `QSvgRenderer`、`QPixmap`、`QPainter`：这些是图形相关的数据结构，用于处理和渲染 SVG 图标。它们在内存中存储图形数据和渲染状态。
- **Interpreter**：
  - 包含脚本执行逻辑，如当前步骤（`current_step`），计时器（`timer`），和一个信号（`response_signal`）。

## 4.2 图形化界面设计

![Screenshot 2023-12-24 at 00.18.49](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-24%20at%2000.18.49.png)

![Screenshot 2023-12-25 at 01.38.54](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-25%20at%2001.38.54.png)



## 4.3 数据持久化

### 用户数据

共编写10份用户数据，使用JSON文件存储。本地设计简化了程序的运行流程，提高执行效率。

```Python
# put_usrprofile_into_json.py
# 本文件用于把用户的个人信息存档入一个JSON文件供查询
import json

# 这是一个包含用户数据的字典
users_data = {
    "user1": {
        "subName": "Netflix",
        "subDueDate": "2023-10-01",
        "subPayment": 49.99,
        "orderNo": "A0001",
        "orderStatus": "Delivered",
        "deliveryDate": "2023-09-25",
        "returnStatus": "Processed",
        "returnDueDate": "2023-09-30",
        "icStatus": "Active",
        "icStorage": "50GB",
        "aiStatus": "Verified",
        "aicontact": "user1@example.com",
        "aiBalance": 100.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 30.00,
        "deviceName": "iPhone 12",
        "faultStatus": "No issues",
        "fixMethod": "N/A",
        "storeName": "Apple Store - MixC, Shenzhen",
        "ATimeSlots": ["10:00AM-11:00AM", "03:00PM-04:00PM"],
        "acStatus": "Active",
        "acDueDate": "2024-10-01"
    },
    "user2": {
        "subName": "Amazon Prime",
        "subDueDate": "2023-11-15",
        "subPayment": 39.99,
        "orderNo": "B0002",
        "orderStatus": "Pending",
        "deliveryDate": "2023-11-10",
        "returnStatus": "Not Processed",
        "returnDueDate": "2023-11-20",
        "icStatus": "Active",
        "icStorage": "30GB",
        "aiStatus": "Verified",
        "aicontact": "user2@example.com",
        "aiBalance": 80.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 25.00,
        "deviceName": "Apple TV 4K",
        "faultStatus": "Hardware issue",
        "fixMethod": "Replacement",
        "storeName": "Apple Store - Union Square, San Francisc",
        "ATimeSlots": ["11:00AM-12:00PM", "04:00PM-05:00PM"],
        "acStatus": "Expired",
        "acDueDate": "2023-11-15"
    },
    "user3": {
        "subName": "Spotify",
        "subDueDate": "2023-12-05",
        "subPayment": 19.99,
        "orderNo": "C0003",
        "orderStatus": "Delivered",
        "deliveryDate": "2023-12-01",
        "returnStatus": "Processed",
        "returnDueDate": "2023-12-10",
        "icStatus": "Active",
        "icStorage": "10GB",
        "aiStatus": "Verified",
        "aicontact": "user3@example.com",
        "aiBalance": 50.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 15.00,
        "deviceName": "HomePod mini",
        "faultStatus": "No issues",
        "fixMethod": "N/A",
        "storeName": "Apple Store - Sydney, Australia",
        "ATimeSlots": ["01:00PM-02:00PM", "06:00PM-07:00PM"],
        "acStatus": "Active",
        "acDueDate": "2024-12-05"
    },
    "user4": {
        "subName": "Apple Music",
        "subDueDate": "2024-01-20",
        "subPayment": 59.99,
        "orderNo": "D0004",
        "orderStatus": "Processing",
        "deliveryDate": "2024-01-15",
        "returnStatus": "Pending",
        "returnDueDate": "2024-01-25",
        "icStatus": "Active",
        "icStorage": "40GB",
        "aiStatus": "Verified",
        "aicontact": "user4@example.com",
        "aiBalance": 90.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 35.00,
        "deviceName": "iPad mini (6th generation)",
        "faultStatus": "Minor issues",
        "fixMethod": "Software update",
        "storeName": "Apple Store - Orchard Road, Singapore",
        "ATimeSlots": ["09:00AM-10:00AM", "02:00PM-03:00PM"],
        "acStatus": "Expired",
        "acDueDate": "2023-01-20"
    },
    "user5": {
        "subName": "Hulu",
        "subDueDate": "2024-02-10",
        "subPayment": 69.99,
        "orderNo": "E0005",
        "orderStatus": "Delivered",
        "deliveryDate": "2024-02-05",
        "returnStatus": "Processed",
        "returnDueDate": "2024-02-10",
        "icStatus": "Active",
        "icStorage": "60GB",
        "aiStatus": "Verified",
        "aicontact": "user5@example.com",
        "aiBalance": 120.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 40.00,
        "deviceName": "iMac 24-inch (M3, 2023)",
        "faultStatus": "No issues",
        "fixMethod": "N/A",
        "storeName": "Apple Store - Dubai Mall, Dubai)",
        "ATimeSlots": ["10:00AM-11:00AM", "03:00PM-04:00PM"],
        "acStatus": "Active",
        "acDueDate": "2025-02-10"
    },
    "user6": {
        "subName": "Disney+",
        "subDueDate": "2024-03-15",
        "subPayment": 29.99,
        "orderNo": "F0006",
        "orderStatus": "Delivered",
        "deliveryDate": "2024-03-10",
        "returnStatus": "Processed",
        "returnDueDate": "2024-03-15",
        "icStatus": "Active",
        "icStorage": "20GB",
        "aiStatus": "Verified",
        "aicontact": "user6@example.com",
        "aiBalance": 70.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 20.00,
        "deviceName": "AirPods Pro",
        "faultStatus": "No issues",
        "fixMethod": "N/A",
        "storeName": "Apple Store - Sanlitun, Beijing",
        "ATimeSlots": ["11:00AM-12:00PM", "04:00PM-05:00PM"],
        "acStatus": "Active",
        "acDueDate": "2025-03-15"
    },
    "user7": {
        "subName": "Microsoft 365",
        "subDueDate": "2024-04-20",
        "subPayment": 49.99,
        "orderNo": "G0007",
        "orderStatus": "Pending",
        "deliveryDate": "2024-04-15",
        "returnStatus": "Not Processed",
        "returnDueDate": "2024-04-25",
        "icStatus": "Active",
        "icStorage": "50GB",
        "aiStatus": "Verified",
        "aicontact": "user7@example.com",
        "aiBalance": 100.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 30.00,
        "deviceName": "Apple Watch Series 7",
        "faultStatus": "Minor issues",
        "fixMethod": "Software update",
        "storeName": "Apple Store - IFC Mall, Chengdu",
        "ATimeSlots": ["09:00AM-10:00AM", "02:00PM-03:00PM"],
        "acStatus": "Active",
        "acDueDate": "2025-04-20"
    },
    "user8": {
        "subName": "Adobe Creative Cloud",
        "subDueDate": "2024-05-25",
        "subPayment": 59.99,
        "orderNo": "H0008",
        "orderStatus": "Processing",
        "deliveryDate": "2024-05-20",
        "returnStatus": "Pending",
        "returnDueDate": "2024-05-30",
        "icStatus": "Active",
        "icStorage": "40GB",
        "aiStatus": "Verified",
        "aicontact": "user8@example.com",
        "aiBalance": 90.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 35.00,
        "deviceName": "iPad Pro 12.9-inch (5th generation)",
        "faultStatus": "Hardware issue",
        "fixMethod": "Replacement",
        "storeName": "Apple Store - West Nanjing Road, Shanghai",
        "ATimeSlots": ["10:00AM-11:00AM", "03:00PM-04:00PM"],
        "acStatus": "Active",
        "acDueDate": "2025-05-25"
    },
    "user9": {
        "subName": "Dropbox",
        "subDueDate": "2024-06-30",
        "subPayment": 79.99,
        "orderNo": "I0009",
        "orderStatus": "Delivered",
        "deliveryDate": "2024-06-25",
        "returnStatus": "Processed",
        "returnDueDate": "2024-07-01",
        "icStatus": "Active",
        "icStorage": "70GB",
        "aiStatus": "Verified",
        "aicontact": "user9@example.com",
        "aiBalance": 150.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 50.00,
        "deviceName": "MacBook Air M1",
        "faultStatus": "No issues",
        "fixMethod": "N/A",
        "storeName": "Apple Store - Covent Garden, London",
        "ATimeSlots": ["11:00AM-12:00PM", "04:00PM-05:00PM"],
        "acStatus": "Expired",
        "acDueDate": "2022-06-30"
    },
    "user10": {
        "subName": "Google Workspace",
        "subDueDate": "2024-07-10",
        "subPayment": 89.99,
        "orderNo": "J0010",
        "orderStatus": "Delivered",
        "deliveryDate": "2024-07-05",
        "returnStatus": "Processed",
        "returnDueDate": "2024-07-10",
        "icStatus": "Active",
        "icStorage": "80GB",
        "aiStatus": "Verified",
        "aicontact": "user10@example.com",
        "aiBalance": 170.00,
        "apStatus": "Enabled",
        "tcStatus": "Active",
        "tcBalance": 60.00,
        "deviceName": "iPhone 13 Pro Max",
        "faultStatus": "No issues",
        "fixMethod": "N/A",
        "storeName": "Apple Store - Fifth Avenue, New York",
        "ATimeSlots": ["09:00AM-10:00AM", "02:00PM-03:00PM"],
        "acStatus": "Active",
        "acDueDate": "2025-07-10"
    }
}

# 将用户数据写入文件
with open('user_data.json', 'w') as file:
    json.dump(users_data, file, indent=4)

```

最终生成的JSON文件如图所示：

<img src="/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-25%20at%2010.33.25.png" alt="Screenshot 2023-12-25 at 10.33.25" style="zoom:67%;" />

### Vars表

以逐级的形式写出，表现各变量分别的使用环境。文字提示了变量存储的内容：

```stylus
Vars/
├── order_cmds/
│   ├── subscription_info/
│   │   ├── subName 订阅内容
│   │   ├── subDueDate 订阅到期时间
│   │   └── subPayment 订阅金额
│   │ 
│   ├── order_status/
│   │   ├── orderNo 订单号
│   │   ├── orderStatus 订单状态
│   │   └── deliveryDate 预计送达时间
│   │ 
│   └── return_status/
│       ├── returnStatus 退货状态
│       └── returnDueDate 预计完成时间
│       
├── account_cmds/
│   ├── icloud_accound/
│   │   ├── icStatus iCloud账号状态
│   │   └── icStorage 存储空间用量
│   │ 
│   ├── apple_id/
│   │   ├── aiStatus AppleID账号状态
│   │   ├── aicontact 默认联系方式
│   │   └── aiBalance 账户余额
│   │ 
│   └── wallet/
│       ├── apStatus 支付服务状态
│       ├── tcStatus 交通卡状态
│       └── tcBalance 交通卡余额
│    
└── support_cmds/
    ├── troubleshoot/
    │ 
    ├── how_to_fix/
    │   ├── deviceName 设备型号
    │   ├── faultStatus 故障状态
    │   └── fixMethod 维修方法
    │ 
    ├── genius_bar/
    │   ├── storeName 推荐店铺
    │   └── ATimeSlots 可预约时间段
    │ 
    └── applecare_plus/
        ├── acStatus AppleCare+ 服务状态
        └── acDueDate AppleCare+ 到期时间
```

## 4.4 前后端交互与数据流动

在我的设计中用户输入和系统应答涉及到`ChatDialog`和`Interpreter`两个类。整个流程是事件驱动的，基于Qt框架的事件循环机制，用户的交互触发事件，事件处理函数进行处理并更新UI或内部状态。在这个模型中，事件循环不断地检查并分发事件，事件可以是用户的输入，也可以是内部的信号。

### 用户输入

1. **用户与界面交互**：
   用户在`ChatDialog`界面的`QLineEdit`组件中输入文本，并点击发送(`QPushButton`)。

2. **发送信号**：
   当用户点击发送按钮时，`sendButton`触发了一个点击事件。这个点击事件通过`sendButton.clicked.connect(self.send_message)`与`ChatDialog`类中的`send_message`方法绑定。

3. **处理用户输入**：
   ``send_message`方法从`QLineEdit`获取文本（用户输入），然后调用`Interpreter`的`receive_user_input`方法，将文本作为参数传递。

4. **传递用户输入**：
   ``Interpreter`的`receive_user_input`方法接收到用户输入，并将其存储在一个全局变量`user_inputted`中，同时停止任何等待用户输入的计时器（如果有的话）。

### 系统应答

1. **处理当前步骤**：
   ``Interpreter`对象处理当前步骤，通过`execute_step`来处理用户的输入。这个方法决定了应该发出什么回应，以及之后的对话流程。

2. **生成应答**：
   在执行步骤时，`speak`方法被调用，根据当前步骤的`expressions`字段来生成系统应答。这些应答可能包括文本消息和/或使用变量数据的动态内容。

3. **发送应答信号**：
   系统应答通过`response_signal.emit(sentence)`发送给`ChatDialog`。`response_signal`是一个`pyqtSignal`，它在`Interpreter`类中定义，并且当系统生成新的应答时发射。

4. **更新UI**：
   ``ChatDialog`类通过`response_signal.connect(chatDialog.append_text)`与`response_signal`信号连接，这意味着每次`Interpreter`发出应答信号时，`ChatDialog`的`append_text`方法都会被调用。

5. **展示应答**：
   在`append_text`方法中，系统应答被添加到`ChatDialog`的`QTextEdit`中，使其在UI上可见。

```plaintext
用户输入:
用户 -> QLineEdit -> send_message() -> Interpreter.receive_user_input() -> USER_INPUTTED (全局变量)

系统应答:
Interpreter.execute_step() -> Interpreter.speak() -> response_signal.emit() -> ChatDialog.append_text() -> QTextEdit
```

## 4.5 多线程

以下代码用于实现多线程，从而支持多用户同时使用本系统。

创建了一份语法树，每个线程分别创建运行环境，使用同一个语法树实例。

```python
    # 为每个用户在不同的线程中运行解释器
    # 每个会话都有它自己的脚本和解释器实例
    def start_interpreter_for_user(script):
        user_interpreter = Interpreter(script)
        user_interpreter.run()

    # 支持3个并发用户
    num_users = 3
    threads = []
    for i in range(num_users):
        thread = threading.Thread(target=start_interpreter_for_user, args=(script,))
        threads.append(thread)
        thread.start()

    # 等待所有线程结束
    for thread in threads:
        thread.join()
```

项目代码模块性很强，因此在不需要多线程支持时，只须注释掉或删掉上述部分代码即可。



# 5 接口

## 5.1 程序间接口

### 从文件到解释器：Parser的工作

1. **文件读取**：
   - `parse_file`函数打开指定的脚本文件，开始按行读取。
   - 每一行文本都被传递给`parse_line`函数进行处理。
2. **行解析**：
   - `parse_line`使用正则表达式通过`re.findall`来拆分每一行，将其分解为一系列的标记（tokens）。
   - 如果遇到注释（以`#`开始的标记），则忽略该标记及之后的内容。
   - 将剩余的有效标记传递给`process_tokens`进行更深层次的解析。
3. **标记处理**：
   - `process_tokens`根据第一个标记确定要执行的操作（如创建步骤、添加对话内容等）。
   - 例如，如果标记是`Step`，则创建一个新的`Step`对象并添加到`Script`对象的步骤列表中。
4. **Script对象构建**：
   - 解析器逐渐构建`Script`对象，该对象包含所有步骤（`Step`对象）以及它们的对话内容和逻辑。
   - 解析完成后，`get_script_from_file`返回这个`Script`对象。

### 解释器：执行脚本

1. **Interpreter初始化**：
   - 解释器在初始化时接收`Script`对象，并设置当前步骤为脚本的入口点。
   - 它还设置一个`QTimer`来处理可能的超时情景。
2. **运行脚本**：
   - `run`方法开始执行脚本，按照步骤顺序处理每一个`Step`对象。
   - 在每个步骤，它可能会调用`speak`方法来发出对话，或者`listen`来等待用户输入。

### 解释器与UI：信号和槽

1. **显示对话**：
   - 解释器使用`response_signal`（一个`pyqtSignal`对象）来将对话内容发送到UI。
   - `ChatDialog`类将`append_text`方法连接到这个信号。当信号发出时，对话内容被添加到UI中。
2. **接收用户输入**：
   - 当用户在UI中输入文本并点击发送按钮时，`ChatDialog`的`send_message`方法被调用。
   - `send_message`方法读取输入框中的文本，然后调用解释器的`receive_user_input`方法。

### 用户输入处理

1. 处理用户输入：
   - 解释器的`receive_user_input`方法接收用户输入，并根据当前步骤的逻辑确定如何处理这些输入。
   - 如果需要等待用户输入，解释器可能会启动`QEventLoop`来暂停执行，直到用户输入到达或超时。

### 模块之间相互作用

`parser`、`interpreter`和`UI`模块之间创建了一个相互作用的流程：

- `parser`模块解析文本文件并构建一个`Script`对象，该对象描述了聊天机器人的行为逻辑。
- 这个`Script`对象被传递给`interpreter`模块，后者执行脚本，同时与用户交互。
- `interpreter`和`UI`之间通过PyQt的信号和槽机制相互通信：`interpreter`发出信号以将内容显示到UI，`UI`则捕捉用户事件并将信息传递给解释器。

## 5.2 人机接口

人机交互接口（Human-Computer Interaction, HCI）是用户与系统交互的中介，它包括了用户界面（UI）的所有组件和逻辑，以及背后支持这些组件的代码。本项目涉及到人机交互接口的部分主要集中在 PyQt 创建的 UI 组件上，以及这些组件如何触发和响应用户操作。UI设计如下图所示：

![IMG_365361AF6C4D-1](/Users/xiangri/Pictures/TyporaPics/IMG_365361AF6C4D-1.jpeg)

### UI 组件

- `QTextEdit`：一个可编辑的文本框，用于显示聊天历史。
- `QLineEdit`：一个文本输入框，让用户输入消息。
- `QPushButton`：一个按钮，用户点击后发送消息。

### 事件处理

PyQt 使用事件驱动模型来处理用户与 UI 组件的交互。

- **点击事件**：当用户点击 UI 中的 `QPushButton` 时，PyQt 会发出一个信号。在您的代码中，这个信号连接到了处理发送消息逻辑的槽（函数）。
  
  ````python
  self.sendButton.clicked.connect(self.send_message)
  
- **文本输入**：当用户在 `QLineEdit` 中输入文本并触发发送按钮时，`send_message` 方法会被调用。这个方法从输入框获取文本，然后将其传递给解释器模块。

### 解释器与 UI 的交互

解释器模块通过触发信号来与 UI 交互：

- **响应用户输入**：当解释器接收到用户输入，它处理输入并更新内部状态。然后发出一个信号，携带需要显示在聊天历史中的消息。

  ````python
  self.response_signal.emit(some_message)
  
- **信号连接到槽**：在 `ChatDialog` 类中，`response_signal` 信号连接到 `append_text` 方法。当信号被触发时，`append_text` 方法会执行，将新消息添加到 `QTextEdit` 中。

  ````python
  interpreter.response_signal.connect(self.append_text)

### 反馈循环

人机交互接口创建了一个用户操作和程序响应的反馈循环：

1. 用户通过 UI 组件进行操作（如输入文本、点击按钮）。
2. UI 组件将操作转化为事件或信号。
3. 解释器响应这些事件，执行业务逻辑。
4. 解释器通过信号向 UI 发送更新。
5. UI 响应这些信号，更新界面元素，为用户提供反馈。



# 6 测试

整体测试过程如下：

1. 对Parser模块进行单元测试
2. 对Interpreter模块进行单元测试
3. 联合两个模块进行系统测试。

## 6.1 自然语言理解的测试--Parser

Parser模块的测试过程如下：

1. 6个功能被整合为4个不同版本的脚本。
2. 为各脚本手动构建预期的语法树。
3. 运行自动测试脚本，通过程序生成对应的语法树，并自动进行匹配。
4. 如果所有脚本实际运行得到的语法树与预期语法树都一致，则测试静默通过；否则输出出现不匹配的脚本、具体位置。

### 测试桩

我将各脚本应当得到的解析结果按状态Step分类，依次写入文件。为4个脚本创建了4份对应的预期结果文件。格式如下：

```
Step #1
Name: step_name
Expressions: ['Expression 1', 'Expression 2', ...]
Listen: [min, max]
Answers: {'branch1_keyword': 'branch1_name', 'branch2_keyword': 'branch2_name', 'branch3_keyword': 'branch3_name', 'branch4_keyword': 'branch4_name', ...}
Default: default_step_name

Step #2
Name: step_name
...
```

售前服务模块的预期结果如同所示：

![Screenshot 2023-12-24 at 16.21.11](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-24%20at%2016.21.11.png)

### Parser的自动测试脚本

`test_parser_V3.py`是Parser模块的自动测试脚本。

```Python
# test_parser_V3.py
import unittest

from parser import get_script_from_file


class TestParser(unittest.TestCase):
    def compare_files(self, script_file, result_file):
        # 读取预期结果文件的内容
        with open(result_file, 'r') as f:
            expected_result = f.read()
        # 调用 get_script_from_file 函数获取实际结果
        get_script_from_file(script_file)
        # 读取运行结果文件的内容
        print2file = "result_" + script_file[7:12] + ".txt"
        with open(print2file, 'r') as f:
            actual_result = f.read()
        # 比较预期结果和实际结果
        self.assertEqual(expected_result, actual_result, f"File {script_file} does not match {result_file}")

    def test_files(self):
        # 定义文件对列表
        files_to_compare = [
            ("script_pre_sale.txt", "parse_pre_sale.txt"),
            ("script_after_sale.txt", "parse_after_sale.txt"),
            ("script_support.txt", "parse_support.txt"),
            ("script_wechat.txt", "parse_wechat.txt"),
        ]
        # 遍历文件对列表，比较每一对文件
        for script_file, result_file in files_to_compare:
            with self.subTest(script_file=script_file, result_file=result_file):
                self.compare_files(script_file, result_file)


if __name__ == '__main__':
    unittest.main()

```

我使用Python的unittest框架进行自动测试。其中，`TestParser` 类继承自 Python `unittest` 框架中用于创建测试用例的基类 `unittest.TestCase`。这个类中定义了两个方法：`compare_files` 方法和 `test_files` 方法。

#### `compare_files` 方法

这个方法接受两个参数：`script_file` 和 `result_file`。它们分别代表了源脚本文件和预期结果文件的路径。

1. **读取预期结果文件**:
   使用 `open` 函数和 `read` 方法，方法读取 `result_file` 的内容并存储在 `expected_result` 变量中。

2. **调用解析函数**:
   使用 `get_script_from_file` 函数从 `script_file` 中提取脚本。这里的假设是该函数会执行一些操作，并可能将结果输出到一个文件中。

3. **读取实际结果文件**:
   构造出实际结果文件的名称，假定是以 `script_file` 的前五个字符命名并加上前缀 `"result_"`。然后读取这个文件的内容到 `actual_result` 变量中。

4. **比较预期和实际结果**:
   使用 `unittest` 框架的 `assertEqual` 方法来比较 `expected_result` 和 `actual_result`。如果不同，测试将失败，并打印出一个指定的错误消息。

#### `test_files` 方法

这个方法定义了一组需要测试的文件对，并遍历这个列表，对每一对文件调用 `compare_files` 方法进行比较。

1. **定义文件对列表**:
   创建一个 `files_to_compare` 列表，其中包含源脚本文件名和预期结果文件名的元组。

2. **遍历文件对**:
   对 `files_to_compare` 列表进行遍历，每次循环将 `script_file` 和 `result_file` 作为参数传递给 `compare_files` 方法。

3. **子测试**:
   使用 `unittest` 中的 `subTest` 上下文管理器来处理每一对文件的比较。这样即使某些子测试失败了，测试套件仍会继续执行其余的测试。

#### 主执行逻辑

代码最后的部分是一个标准的 Python 模式，当在命令行直接运行这个脚本时，它会调用 `unittest.main()` 函数来启动测试运行器，该运行器将执行 `TestParser` 类中定义的所有测试方法。

```python
if __name__ == '__main__':
    unittest.main()
```

### 运行自动测试脚本

在命令行通过以下命令运行`test_parser_V3.py`：

```sh
python3 test_parser_V3.py
```

自动对4对脚本-预期结果对进行测试。若通过测试则静默无输出：

![Screenshot 2023-12-22 at 22.42.36](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-22%20at%2022.42.36.png)

不匹配则会报告出错的情况：

![Screenshot 2023-12-22 at 22.43.58](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-22%20at%2022.43.58.png)

```python
# test_parser_V1.py
import unittest

from parser import get_script_from_file


class TestParser(unittest.TestCase):
    def compare_files(self, script_file, result_file):
        # 读取预期结果文件的内容
        with open(result_file, 'r') as f:
            expected_result = f.read()
        # 调用 get_script_from_file 函数获取实际结果
        get_script_from_file(script_file)
        # 读取运行结果文件的内容
        print2file = "result_" + script_file[7:12] + ".txt"
        with open(print2file, 'r') as f:
            actual_result = f.read()
        # 比较预期结果和实际结果
        self.assertEqual(expected_result, actual_result, f"File {script_file} does not match {result_file}")

    def test_files(self):
        # 定义文件对列表
        files_to_compare = [
            ("script_pre_sale.txt", "parse_pre_sale.txt"),
            ("script_after_sale.txt", "parse_after_sale.txt"),
            ("script_support.txt", "parse_support.txt"),
            ("script_wechat.txt", "parse_wechat.txt"),
        ]
        # 遍历文件对列表，比较每一对文件
        for script_file, result_file in files_to_compare:
            with self.subTest(script_file=script_file, result_file=result_file):
                self.compare_files(script_file, result_file)


if __name__ == '__main__':
    unittest.main()

```

最终形成的文件结构如下：

#### Parser模块测试预期结果文件

- `parse_pre_sale.txt`
- `parse_after_sale.txt`
- `parse_support.txt`
- `parse_wechat.txt`

#### Parser模块测试运行结果文件

- `result_pre_s.txt`
- `result_after.txt`
- `result_custo.txt`
- `result_wecha.txt`

## 6.2 媒体播放器的测试--Interpreter

以CLI版本的`Interpreter.py`进行自动单元测试。Interpreter模块的测试过程如下：

1. 创建一系列测试桩，模拟用户输入。依次存储在文件`input_脚本名称.txt`中；
2. 为各测试桩准备预期的系统输出流，依次存储在文件`expect_脚本名称.txt`中；
3. 创建自动测试脚本，自动执行多次测试；
4. 测试中依次比较各对expect期望输入和实际运行结果test_output.txt是否一致；
5. 如果所有脚本实际运行得到的输出与预期输出逐句一致，则测试静默通过；否则输出出现不匹配的脚本、具体位置。

### 测试桩

为各脚本均创建对应的txt文件，一行代表用户的一次输入内容。例如脚本script_wechat对应的测试桩如下：

```
产品
手机
电脑
耳机
平板
账单
user1
订阅
退货
订单
促销
教育
节日季
商务
医疗
翻新
人工
```

### Interpreter的自动测试脚本

`test_interpreter_V1.py`是Interpreter模块的自动测试脚本。

自动测试的整体流程为：

1. 设置了一个文件后缀列表并进行遍历。
2. 对于每个后缀，构造了脚本、输入和预期输出文件的文件名。
3. 调用`run_interpreter_with_input`，用输入和脚本文件运行解释器。
4. 然后通过调用`compare_output`比较解释器写入的实际输出和预期输出。
5. 如果实际输出和预期输出不匹配，`unittest`会报告失败。

```python
# test_interpreter_V1.py
import sys
import unittest

from interpreter import Interpreter
from parser import get_script_from_file


class InterpreterTest(unittest.TestCase):
    def run_interpreter_with_input(self, input_file, script_file):
        # 准备脚本对象
        script = get_script_from_file(script_file)
        # 将 stdout 重定向，以捕获解释器的打印输出
        self.original_stdout = sys.stdout
        self.output_file = 'test_output.txt'
        sys.stdout = open(self.output_file, 'w')
        # 重定向 stdin 从输入文件中读取
        with open(input_file, 'r') as input_data:
            original_stdin = sys.stdin
            sys.stdin = input_data
            interpreter = Interpreter(script)
            try:
                interpreter.run()
            except SystemExit as e:
                # 捕获 SystemExit 异常
                self.assertEqual(e.code, 666)  # 检查退出码是否为预期值
            # 重置 stdin
            sys.stdin = original_stdin

        # 关闭重定向的 stdout 文件并重置 stdout
        sys.stdout.flush()  # Flush 标准输出缓冲区 stdout buffer
        sys.stdout.close()  # 手动关闭文件，全部全部数据已经写回
        sys.stdout = self.original_stdout  # 重置stdout为初始状态

    def compare_output(self, expected_file):
        # 读取预期的输出
        with open(expected_file, 'r') as file:
            expected_output = file.read()
        # 读取测试的实际输出
        with open(self.output_file, 'r') as file:
            actual_output = file.read()
        self.maxDiff = None
        # 比较预期输出和实际输出
        self.assertEqual(expected_output, actual_output)

    def test_interpreter(self):
        # 定义输入和预期输出文件
        names_index = ['pre_sale.txt', 'after_sale.txt', 'support.txt', 'wechat.txt']
        # 遍历文件列表，比较每一对文件
        for i in names_index:
            script_file = 'script_' + i
            input_file = 'input_' + i
            expected_file = 'expect_' + i
            with self.subTest(input_file=input_file, expected_file=expected_file):
                # 使用提供的输入运行解释器
                self.run_interpreter_with_input(input_file, script_file)
                # 将输出与预期输出进行比较
                self.compare_output(expected_file)


if __name__ == '__main__':
    unittest.main()

```


- `run_interpreter_with_input`方法负责设置并运行给定的脚本文件和输入文件的解释器。它将标准输入`stdin`重定向到输入文件，将标准输出`stdout`重定向到文件，以便稍后进行比较。

- `compare_output`方法比较解释器的输出（写入`test_output.txt`中）和存储在`expected_file`中的预期输出。

- `test_interpreter`方法是由`unittest`框架调用的实际测试方法。它遍历预定义文件名列表，构建脚本、输入和预期文件的路径，然后调用`run_interpreter_with_input`和`compare_output`方法执行测试。

- 主程序块检查脚本是直接运行的，如果是，就调用`unittest.main()`，运行文件中的所有测试（即以test开头的方法，本脚本的）。

### 运行自动测试脚本

在命令行通过以下命令运行`test_interpreter_V1.py`：

```sh
python3 test_interpreter_V1.py
```

若通过测试则静默无输出：

![Screenshot 2023-12-24 at 21.20.19](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-24%20at%2021.20.19.png)

不匹配则会报告出错的情况：

![Screenshot 2023-12-24 at 21.30.46](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-24%20at%2021.30.46.png)

注意：本部分输出使用`-`和`+`来标记不同之处，其中`-`表示期望的输出中应该有但实际输出中没有的文本，`+`表示实际输出中多出来的文本。

```python
# test_interpreter_V1.py
import sys
import unittest

from interpreter import Interpreter
from parser import get_script_from_file


class InterpreterTest(unittest.TestCase):
    def run_interpreter_with_input(self, input_file, script_file):
        # 准备脚本对象
        script = get_script_from_file(script_file)
        # 将 stdout 重定向，以捕获解释器的打印输出
        self.original_stdout = sys.stdout
        self.output_file = 'test_output.txt'
        sys.stdout = open(self.output_file, 'w')
        # 重定向 stdin 从输入文件中读取
        with open(input_file, 'r') as input_data:
            original_stdin = sys.stdin
            sys.stdin = input_data
            interpreter = Interpreter(script)
            try:
                interpreter.run()
            except SystemExit as e:
                # 捕获 SystemExit 异常
                self.assertEqual(e.code, 666)  # 检查退出码是否为预期值
            # 重置 stdin
            sys.stdin = original_stdin

        # 关闭重定向的 stdout 文件并重置 stdout
        sys.stdout.flush()  # Flush 标准输出缓冲区 stdout buffer
        sys.stdout.close()  # 手动关闭文件，全部全部数据已经写回
        sys.stdout = self.original_stdout  # 重置stdout为初始状态

    def compare_output(self, expected_file):
        # 读取预期的输出
        with open(expected_file, 'r') as file:
            expected_output = file.read()
        # 读取测试的实际输出
        with open(self.output_file, 'r') as file:
            actual_output = file.read()
        self.maxDiff = None
        # 比较预期输出和实际输出
        self.assertEqual(expected_output, actual_output)

    def test_interpreter(self):
        # 定义输入和预期输出文件
        names_index = ['pre_sale.txt', 'after_sale.txt', 'support.txt', 'wechat.txt']
        # 遍历文件列表，比较每一对文件
        for i in names_index:
            script_file = 'script_' + i
            input_file = 'input_' + i
            expected_file = 'expect_' + i
            with self.subTest(input_file=input_file, expected_file=expected_file):
                # 使用提供的输入运行解释器
                self.run_interpreter_with_input(input_file, script_file)
                # 将输出与预期输出进行比较
                self.compare_output(expected_file)


if __name__ == '__main__':
    unittest.main()

```

最终得到的文件结构如下：

### Interpreter模块模拟用户输入文件

- `input_pre_sale.txt`
- `input_after_sale.txt`
- `input_support.txt`
- `input_wechat.txt`

### Interpreter模块预期结果文件

- `expect_pre_sale.txt`
- `expect_after_sale.txt`
- `expect_support.txt`
- `expect_wechat.txt`

## 6.3 全局测试与回归测试

在本项目中，因为工作流是先调用Parser模块生成语法树，再调用Interpreter模块解释执行。两步骤环环相扣不可分割，进行Interpreter模块测试时必然会用到Parser模块生成的正确的语法树结果。

在Python的`unittest`框架中，测试套件（Test Suite）用于组织和执行测试，使得测试可以批量运行，而不是单独执行每个测试用例。因此我使用测试套件来组织全局测试。

代码更新迭代后需要验证功能的完整性。因此执行本测试套件同样可以实现回归测试。

![Screenshot 2023-12-24 at 23.33.44](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-24%20at%2023.33.44.png)

```python
# testsuite.py
import unittest

if __name__ == "__main__":
    loader = unittest.TestLoader()  # 创建测试加载器
    suite = unittest.TestSuite()  # 创建测试套件
    suite.addTests(loader.discover(start_dir='.', pattern='test_*.py'))  # 添加测试到测试套件
    runner = unittest.TextTestRunner(verbosity=2)  # 运行测试套件
    runner.run(suite)

```



### 测试模块的文件

- `test_parser_V3.py ` parser模块的自动测试脚本
- `test_interpreter_V1.py`  interpreter模块的自动测试脚本
- `testsuite.py`  全局测试的自动测试脚本，即一个测试套件



# 7 风格

本项目采用Python开发，遵循 [PEP 8](https://www.python.org/dev/peps/pep-0008/) 代码风格指南。我将其核心要点归纳如下：

## PEP8 主要规则

1. **缩进**
   - 使用 4 个空格进行缩进，不要使用制表符。
   - 对于行连续，应该使用垂直对齐或使用挂起缩进（4个空格）。
2. **行宽**
   - 每行代码不应超过 79 个字符；对于含有较长字符串或注释的行，可以延伸到 99 个字符。
3. **空白**
   - 在逗号、冒号、分号后使用空格，但不要在其前使用。
   - 函数和类定义后留一行空白，方法定义之间留一行空白。
   - 在使用二元运算符时，通常在其前后各有一个空格。
4. **导入**
   - 导入应该分行，并且通常放在文件顶部。
   - 应该按照标准库、第三方库、应用程序指定模块顺序分组，并在每组之间留一个空行。
5. **命名约定**
   - 函数名、变量名应该小写，单词之间用下划线分隔。
   - 常量名应该使用全大写字母，单词之间用下划线分隔。
   - 类名应该使用驼峰命名法。
6. **表达式和语句**
   - 不要在不必要的地方使用括号。
   - 方法链调用时，可以使用适当的缩进来提高可读性。
7. **注释**
   - 注释应该是完整的句子，如果注释是短语或句子，其首字母应该大写。
   - 行注释应该至少用两个空格与代码分开。
9. **空行**
   - 在顶层函数和类定义之间用两个空行。
   - 类的方法定义之间用一个空行。
10. **比较**
    - 对于单例值的比较，如 `None`，应该使用 `is` 或 `is not`，而不是等于操作符。
11. **异常**
    - 使用 `try/except` 语句来捕捉异常，而不是依赖于 Python 的 `on error` 机制。
12. **构造函数**
    - 如果一个类的构造函数不接受额外参数，就省略掉。

## 7.1 注释规范

PEP 8 对 Python 代码中的注释的主要要求和建议总结如下：

1. **块注释**:
   - 块注释通常用于解释代码段的工作原理或某个部分的目的。
   - 应该与代码缩进相同。
   - 每行注释前应有一个 `#` 符号，然后是一个空格，再接着是注释文本。
   - 如果注释是一个完整的句子，首字母应当大写，句子应该以句号结束。

2. **行内注释**:
   - 行内注释紧随在代码之后，并且至少应该有两个空格与代码分隔。
   - `#` 和注释之间应有一个空格。
   - 行内注释应该简洁明了，避免冗长的描述。
   - 不是所有的行都需要行内注释，只有那些不是一目了然的地方才需要。

3. **文档字符串 (Docstrings)**:
   - 对于所有的公有模块、函数、类和方法，文档字符串是必要的。
   - 文档字符串用三引号 `"""` 包围，并且描述了函数的作用和参数等信息。
   - 文档字符串应该遵循 [PEP 257](https://www.python.org/dev/peps/pep-0257/)。

4. **空格**:
   - 注释前后应当有适当的空格分隔，以防止拥挤的代码和注释。

5. **注释的内容**:
   - 注释应当有意义，解释那些不是立即显而易见的代码部分。
   - 避免在注释中说明显而易见的事情。

示例：

```python
    def listen(self, step):
    """位于Interpreter类中，用于监听用户的输入。
        Args:
        param1 (self): 代表Interpreter类实例本身
        param2 (step): 代表当前所在的状态step
        
    		Returns:
        intent: 去往的下一个状态的标识符
		"""
        intent = ''
        if step.listen:
            self.loop = QEventLoop()  # 创建局部事件循环：一个QEventLoop对象
            self.timer.start(20000)  # 局部事件循环，等待用户输入，20秒后超时退出
            self.loop.exec_()  # 启动本地事件循环，直到 loop.exit() 被调用
            intent = user_inputted
        elif step.default:
            intent = 'default'
        else:
            QTimer.singleShot(3500, self.closeApplication)
        return intent
```

## 7.2 命名规范

本项目严格遵循 PEP8 的命名规范，具体采用的标准列举如下：

1. **模块名**: 模块名应该短小，并且全部使用小写字母。可以使用下划线来提高可读性（例如，`parser.py`）。
2. **包名**: 包名也应该短小，并且全部使用小写字母。不推荐使用下划线（例如，`numpy`、`json`）。
3. **类名**: 类名通常使用单词首字母大写的方式，这种方式被称为CapWords或CamelCase（例如，`ChatDialog`）。
4. **异常名**: 因为异常实际上也是类，所以应该使用类命名的约定。但是，如果异常实际上是一个错误，那么该异常的名称应该以`Error`作为后缀（例如，`SystemExit`）。
5. **函数名**: 函数名应该全部小写，单词之间可以用下划线分隔以提高可读性（例如，`parse_file`）。
6. **方法名和实例变量**: 方法名和实例变量也应该全部小写，并且单词之间可以使用下划线分隔（例如，`receive_user_input`）。
7. **常量名**: 常量名应该全部使用大写字母，单词之间用下划线分隔（例如，`USER_INPUTTED`）。

**同时也参照了《程序设计实践》对命名风格的建议：**

1. 命名要准确表达用途（例如，`execute_step`）。 
2. 名字不是越长越好。一般来说，全局变量用具有描述意义的长名字（例如，`USER_INPUTTED`），局部变量用短名字会显得程序更简洁（例如，`loop`、`script`、`timer`）。 
3. 类里面的成员的名字，不要再重复类名（例如，`Interpreter`类内的信号命名为`response_signal`）。 
4. 用动词或者动词+名词定义函数名（例如，`append_text`、`listen`）。 
5. 返回布尔值的函数名应该是一个命题，不应该是一个动作（例如，`check_user_exists`）。 
6. 命名尽可能简单明了，不要用“否定之否定”。

**说明**：PyQt遵循的是自己的命名约定而非 PEP8，因为是基于PyQt的原始语言 C++ 的命名风格驼峰式。该框架部分的代码我遵循了框架的风格，以保持与框架的一致性和其他可能使用该框架的代码的互操作性（例如，`QWidget`、`initUI`、`sendButton`、`QLineEdit`）。

## 7.3 文件命名规范

文件名的目的是为了快速识别文件内容和用途，因此我项目中的文件采用==**简短且具有描述性**==的名称：

### 代码文件

- `Parser.py`	语法分析模块的代码
- `Interpreter.py`	解释执行模块的代码，CLI版本
- `Interpreter_GUI.py `	解释执行模块的代码，GUI交互版本
- `test_parser_V3.py`	Parser模块的自动测试脚本
- `test_interpreter_V1.py`	CLI版Interpreter模块的自动测试脚本
- `test_interpreter_GUI_V2.py`	GUI版Interpreter模块的自动测试脚本
- `put_usrprofile_into_json.py`	用于将用户信息存为JSON格式的文件

### 脚本

- `script_pre_sale.txt`
- `script_after_sale.txt`
- `script_support.txt`
- `script_wechat.txt`

### Parser模块测试预期结果

- `parse_pre_sale.txt`
- `parse_after_sale.txt`
- `parse_support.txt`
- `parse_wechat.txt`

### Parser模块测试运行结果

- `result_pre_s.txt`
- `result_after.txt`
- `result_custo.txt`
- `result_wecha.txt`

### Interpreter模块模拟用户输入文件

- `input_pre_sale.txt`
- `input_after_sale.txt`
- `input_support.txt`
- `input_wechat.txt`

### Interpreter模块预期结果

- `expect_pre_sale.txt`
- `expect_after_sale.txt`
- `expect_support.txt`
- `expect_wechat.txt`



# 8 源代码

## parser.py

```Python
# parser.py
import re
import sys


class Step:
    def __init__(self, name):
        self.name = name
        self.expressions = []  # 用于存储多个 SAY 命令的句子。
        self.listen = []  # 存储听取时长的起始和结束范围。
        self.answers = {}  # 包含可能的后继状态。
        self.default = None  # 如果没有匹配，则转移到默认状态。
        self.awake = None  # 如果无响应，则转移到唤醒状态。


class Script:
    def __init__(self):
        self.steps = []  # 脚本中所有状态的列表。
        self.vars = None  # 脚本使用的所有变量。
        self.actions = {}  # 可用的所有动作。
        self.entry = None  # 脚本的入口状态。

    def add_step(self, step):
        self.steps.append(step)


# 解析文件并返回一个 Script 对象。
def parse_file(file_name):
    script = Script()
    with open(file_name, 'r') as file:
        for line in file:
            line = line.strip()
            if line and not line.startswith('#'):
                parse_line(line, script)
    return script


# 解析文件的一行
def parse_line(line, script):
    # 分割行，并保持引号内的字符串不变。
    tokens = re.findall(r'(?:[^\s,"]|"(?:\\.|[^"])*")+', line)
    # 处理每个分词，如果遇到 '#' 开始的分词则停止。
    for token in tokens:
        if token.startswith('#'):
            index = tokens.index(token)
            tokens = tokens[:index]
            break
    process_tokens(tokens, script)


# 根据首个分词的类型处理剩余的分词。
def process_tokens(tokens, script):
    if tokens[0] == 'Step':
        process_step(script, tokens)
    current_step = script.steps[-1]
    if tokens[0] == 'SAY':
        process_say(current_step, tokens)
    elif tokens[0] == 'LISTEN':
        process_listen(current_step, tokens)
    elif tokens[0] == 'BRANCH':
        process_branch(current_step, script, tokens)
    elif tokens[0] == 'AWAKE':
        current_step.awake = tokens[1]
    elif tokens[0] == 'DEFAULT':
        current_step.default = tokens[1]


# 设置当前步骤的 LISTEN 参数。
def process_listen(current_step, tokens):
    current_step.listen.append(int(tokens[1]))
    current_step.listen.append(int(tokens[2]))


# 向当前步骤添加 SAY 命令的内容。
def process_say(current_step, tokens):
    if len(tokens) == 3:
        current_step.expressions.append(tokens[1].strip('"'))
        current_step.expressions.append(tokens[2])  # 把变量像句子一样存进list，执行的时候检查
    else:
        current_step.expressions.append(tokens[1].strip('"'))


# 创建一个新的 Step 实例并添加到脚本中。
def process_step(script, tokens):
    current_step = Step(tokens[1])
    if len(script.steps) == 0:
        script.entry = current_step
    script.add_step(current_step)


# 为当前步骤添加 BRANCH 条件及其后继状态。
def process_branch(current_step, script, tokens):
    input_token = tokens[1].strip('"')
    current_step.answers[input_token] = tokens[2]
    if input_token not in script.actions:
        script.actions[input_token] = tokens[2].strip('"')


# 解析表达式中的变量和文本。
def process_expression(tokens):
    expression = []
    for token in tokens:
        if token.startswith('#'):
            break
        elif token.startswith('<$') and token.endswith('>'):
            var_name = token[2:-1]
            expression.append(var_name)
            script.vars.append(var_name)
        else:
            expression.append(token.strip('"'))
    return expression


# 从文件中获取脚本并打印到文本文件。
def get_script_from_file(file_name):
    result_script = parse_file(file_name)
    print2txt(file_name, result_script)
    return result_script


# 将脚本信息输出到终端。
def print2terminal(script):
    global index, step
    print("Steps:", script.steps)
    print("Vars:", script.vars)
    print("Actions:", script.actions)
    print("Entry:", script.entry)
    print("Vars:", script.vars)
    # 使用enumerate()函数打印循环的号码
    for index, step in enumerate(script.steps, start=1):  # start=1 表示编号从1开始
        print("Step #{}".format(index))  # 打印当前的步骤号码
        print("Name:", step.name)
        print("Expressions:", step.expressions)
        print("Listen:", step.listen)
        print("Answers:", step.answers)
        print("Awake:", step.awake)
        print("Default:", step.default)


# 将脚本信息输出到文本文件。
def print2txt(file_name, result_script):
    print2file = "result_" + file_name[7:12] + ".txt"
    global file, index, step
    # 打开一个文件用于写入，如果文件不存在则创建它
    with open(print2file, 'w', encoding='utf-8') as file:
        # 使用enumerate()函数打印循环的号码
        for index, step in enumerate(result_script.steps, start=1):  # start=1 表示编号从1开始
            file.write("Step #{}\n".format(index))  # 写入当前的步骤号码
            file.write("Name: {}\n".format(step.name))
            file.write("Expressions: {}\n".format(step.expressions))
            file.write("Listen: {}\n".format(step.listen))
            file.write("Answers: {}\n".format(step.answers))
            file.write("Awake: {}\n".format(step.awake))
            file.write("Default: {}\n\n".format(step.default))


# 检查命令行参数，解析文件，并运行脚本。
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python3 Parser.py <parameter>")
        sys.exit(1)

    file_name = sys.argv[1]
    script = get_script_from_file(file_name)

```

## interpreter_GUI.py

```Python
# interpreter_GUI.py
import json
import sys
import time

from PyQt5.QtCore import Qt, QObject, pyqtSignal, QTimer, QEventLoop, QByteArray
from PyQt5.QtGui import QIcon, QPixmap, QPainter
from PyQt5.QtSvg import QSvgRenderer
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QPushButton, QTextEdit, QLineEdit, QHBoxLayout

from parser import get_script_from_file

USER_INPUTTED = ''  # 用来存储用户的输入

# SVG 数据，用于按钮图标
svg_data = """<svg width="24" height="24" viewBox="0 0 24 24" fill="none"> <path d="M7 11L12 6L17 11M12 18V7" 
stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </svg>"""


class ChatDialog(QWidget):
    def __init__(self, interpreter):
        super().__init__()
        self.interpreter = interpreter  # 这行代码必须在initUI()调用之前，否则会引用未初始化的interpreter！
        self.initUI()
        print('ChatDialog initialized __init__')

    def initUI(self):
        # 设置窗口标题和大小
        self.setWindowTitle(' Apple 支持')
        self.setGeometry(300, 100, 450, 600)

        # 创建垂直布局
        mainLayout = QVBoxLayout()

        # 创建文本编辑区域，用于显示对话历史
        self.textEdit = QTextEdit()
        self.textEdit.setReadOnly(True)
        mainLayout.addWidget(self.textEdit)

        # 创建横向布局用于放置输入框和发送按钮
        bottomLayout = QHBoxLayout()

        # 创建输入框，并设置拉伸因子为1使其填满剩余空间
        self.inputLine = QLineEdit(self)
        bottomLayout.addWidget(self.inputLine, 1)

        # 创建按钮并设置SVG图标
        self.sendButton = QPushButton('发送', self)
        svg_bytes = QByteArray(svg_data.encode('utf-8'))
        svg_renderer = QSvgRenderer(svg_bytes)
        pixmap = QPixmap(24, 24)
        pixmap.fill(Qt.transparent)  # 确保透明背景
        painter = QPainter(pixmap)
        svg_renderer.render(painter)
        painter.end()
        self.sendButton.setIcon(QIcon(pixmap))

        # 创建发送按钮
        # sendButton = QPushButton('发送', self)
        self.sendButton.clicked.connect(self.send_message)  # 将按钮点击事件连接到 send_message 方法
        self.sendButton.clicked.connect(self.interpreter.on_submit)  # 当按钮被点击时，退出事件循环

        # 添加发送按钮到横向布局，同时添加弹性空间以推送到右下角
        bottomLayout.addWidget(self.sendButton)

        # 将横向布局添加到主垂直布局中
        mainLayout.addLayout(bottomLayout)

        # 设置布局
        self.setLayout(mainLayout)

    # 收到消息时打印在GUI
    def append_text(self, text, speaker="Apple"):
        print('收到：' + text)
        if speaker == "User":
            self.textEdit.append(
                "<b style='font-size:18pt;'>You: </b> <span style='font-size:14pt;'>" + text + "</span>")
        else:
            self.textEdit.append(
                "<b style='font-size:18pt;'>Apple: </b> <span style='font-size:14pt;'>" + text + "</span>")

    # 发送用户输入到Interpreter并清空输入框，通过信号接收回复
    def send_message(self):
        user_input = self.inputLine.text()
        self.interpreter.receive_user_input(user_input)  # 指明用interpreter实例的receive_user_input方法接受user_input
        self.append_text(user_input, speaker="User")
        self.inputLine.clear()


class Interpreter(QObject):
    # 定义一个用于发送响应的信号
    response_signal = pyqtSignal(str)

    # 初始化Interpreter类的实例变量。
    def __init__(self, script):
        super().__init__()
        self.loop = None
        self.script = script
        self.current_step = script.entry
        self.timer = QTimer()  # 创建一个计时器
        self.timer.setSingleShot(True)  # 设置为一次性触发
        self.timer.timeout.connect(self.on_timeout)  # 超时连接到槽函数

    def run(self):
        while self.current_step:
            print("Current step:", self.current_step.name)
            self.execute_step(self.current_step)

    def execute_step(self, step):
        # 执行说话动作
        self.speak(step.expressions)
        intent = self.listen(step)
        if step.name.startswith("validation"):
            valid, self.script.vars = self.check_user_exists(intent)
            if valid:
                intent = 'pass'
            else:
                intent = 'fail'
        # 获取下一个步骤的 ID
        next_step_id = self.get_next_step_id(step, intent)
        # 将当前步骤设置为新的步骤
        self.current_step = self.find_step_by_id(next_step_id)

    def speak(self, expression):
        output = ""
        for sentence in expression:
            if sentence.endswith('：'):
                output += sentence
            elif sentence.startswith("<$") and sentence.endswith(">"):
                # 剥离变量sentence开头的"<$"和结尾的">"
                expect_var = sentence[2:-1]
                # 使用变量名（键）检索数据。如果键不存在，返回默认值
                var_value = self.script.vars.get(expect_var, 'NULL')
                output += str(var_value)
                output += '<br>'
            else:
                output += sentence
        self.response_signal.emit(output)  # 发射整个输出而不是逐句s

    # 执行说话动作并获得用户意图
    def listen(self, step):
        intent = ''
        if step.listen:
            self.loop = QEventLoop()  # 创建局部事件循环：一个QEventLoop对象
            self.timer.start(20000)  # 局部事件循环，等待用户输入，20秒后超时退出
            print('开始等待20秒')
            self.loop.exec_()  # 启动本地事件循环，直到 loop.exit() 被调用
            intent = USER_INPUTTED
        elif step.default:
            intent = 'default'
        else:
            QTimer.singleShot(3500, self.closeApplication)
        return intent

    # 在点击按钮时退出事件循环
    def on_submit(self):
        self.loop.exit()

    # 在超时时退出事件循环
    def on_timeout(self):
        global USER_INPUTTED
        USER_INPUTTED = ''
        self.loop.exit()  # 添加这行来退出事件循环

    # 根据用户意图获取下一个步骤的ID。
    def get_next_step_id(self, step, intent):
        if intent == '':
            return step.awake
        elif intent in step.answers:
            return step.answers[intent]
        else:
            return step.default

    def find_step_by_id(self, step_id):
        for step in self.script.steps:
            if step.name == step_id:
                return step
        return None

    # 检查某个用户是否存在
    def check_user_exists(self, username):
        with open('user_data.json', 'r') as file:
            user_data = json.load(file)
        if username in user_data:
            return True, user_data[username]
        else:
            return False, None

    # 返回初始的客服消息
    def initial_message(self):
        return "正在为你创建对话"

    def receive_user_input(self, user_input):
        # 接受用户输入
        global USER_INPUTTED
        USER_INPUTTED = user_input
        self.timer.stop()  # 停止计时器，因为已经收到输入

    def closeApplication(self):
        QApplication.quit()  # 退出应用程序


# 检查命令行参数并启动应用程序
if __name__ == '__main__':
    # 检查是否有足够的参数传递给脚本
    if len(sys.argv) < 2:
        print("Usage: python3 script.py <parameter>")
        sys.exit(1)  # 退出程序并返回错误代码

    # 第一个参数是脚本名，第二个参数是第一个用户提供的参数
    file_name = sys.argv[1]
    script = get_script_from_file(file_name)
    app = QApplication(sys.argv)
    print("QApplication created")  # 确认应用程序已创建

    interpreter = Interpreter(script)  # 创建后端，Interpreter对象
    chatDialog = ChatDialog(interpreter)  # 创建前端， ChatDialog 对象
    print("ChatDialog created")  # 确认聊天对话框对象已创建

    interpreter.response_signal.connect(chatDialog.append_text)  # 连接信号和槽
    chatDialog.show()
    print("chatDialog.show() called")  # 确认 show 方法被调用

    chatDialog.append_text(interpreter.initial_message(), speaker="SYS")
    interpreter.run()

    exit_code = app.exec_()
    sys.exit(exit_code)

```

## 运行方法

注意：首先确保运行所需的各组件放在同一文件夹内再执行。或在参数中添加文件绝对或相对路径。

### 程序

运行格式为：

```
python3 <源代码文件名> <脚本名>
```

只运行Parser，没有输出

```shell
python3 parser.py script_wechat.txt
```

![Screenshot 2023-12-25 at 10.28.30](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-25%20at%2010.28.30.png)

运行CLI版本，在命令行进行交互

```sh
python3 interpreter.py script_pre_sale.txt
```

![Screenshot 2023-12-25 at 10.29.23](/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-25%20at%2010.29.23.png)

运行GUI版本，图形化界面交互

```
python3 interpreter_GUI.py script_after_sale.txt
```

<img src="/Users/xiangri/Pictures/TyporaPics/Screenshot%202023-12-24%20at%2022.20.58.png" alt="Screenshot 2023-12-24 at 22.20.58" style="zoom:50%;" />

### 测试

运行interpreter的自动测试

```
python3 test_interpreter_V1.py
```

运行parser的自动测试

```
python3 test_parser_V3.py
```

运行全局自动测试，回归测试

```
python3 testsuite.py
```

